---
name: BIP47 - PayNym

description: Как работают PayNyms
---
***ВНИМАНИЕ:** После ареста основателей кошелька Samourai и изъятия их серверов 24 апреля, использование приложения стало невозможным для пользователей, не имеющих собственного Dojo. BIP47 по-прежнему доступен в кошельке Sparrow для всех пользователей и **в кошельке Samourai только для пользователей, имеющих Dojo**.*

_Мы внимательно следим за развитием этого дела, а также за развитием связанных с ним инструментов. Можете быть уверены, что мы обновим этот учебник, как только появится новая информация._

_Этот учебник предоставлен только для образовательных и информационных целей. Мы не поддерживаем и не поощряем использование этих инструментов в преступных целях. Каждый пользователь несет ответственность за соблюдение законов в своей юрисдикции._

---

> "Он слишком большой," - говорили все, и индюк, который родился с шпорами и думал, что он император, раздулся, как корабль под полными парусами, и с гневом пошел прямо на него, его глаза были красны как огонь. Бедный маленький утенок не знал, стоять ли на месте или убегать, и был очень несчастен, потому что его презирали все утки во дворе.

![BIP47, иллюстрация некрасивого утенка](assets/1.webp)

Одна из наиболее значительных проблем протокола Bitcoin - повторное использование адресов. Прозрачность и распределенность сети делают эту практику опасной для конфиденциальности пользователей. Чтобы избежать проблем, связанных с этим, рекомендуется использовать новый пустой адрес получения для каждого нового входящего платежа на кошелек, что в некоторых случаях может быть сложно достичь.

Этот компромисс существует столько же, сколько и Белая книга. Сатоши уже предупреждал нас об этом риске в своей работе, опубликованной в конце 2008 года:

> "В качестве дополнительного барьера, для каждой транзакции следует использовать новую пару ключей, чтобы они не были связаны с общим владельцем."

Существует множество решений для приема множественных платежей без повторного использования адреса. У каждого из них есть свои компромиссы и недостатки. Среди всех этих решений есть [BIP47](https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki), предложение, разработанное Justus Ranvier и опубликованное в 2015 году, которое позволяет генерировать повторно используемые платежные коды. Его цель - позволить совершать множество транзакций одному и тому же лицу без повторного использования адреса.

Изначально это предложение встретило пренебрежение со стороны части сообщества, и оно никогда не было добавлено в Bitcoin Core. Однако некоторые программные продукты все же решили реализовать его самостоятельно. Например, кошелек Samourai разработал собственную реализацию BIP47: PayNym. Сегодня эта реализация доступна в кошельке Samourai для смартфонов, а также в [Sparrow Wallet](https://sparrowwallet.com/) для ПК.

Со временем Samourai запрограммировал новые функции, непосредственно связанные с PayNym. Теперь существует целая экосистема инструментов, доступных для оптимизации конфиденциальности пользователя на основе PayNym и BIP47.
В этой статье вы узнаете принцип работы BIP47 и PayNym, механизмы этих протоколов и практические приложения, которые из них вытекают. Я буду говорить только о первой версии BIP47, которая в настоящее время используется для PayNym, но версии 2, 3 и 4 работают практически таким же образом.
Единственное значительное отличие обнаруживается в транзакции уведомления. Версия 1 использует простой адрес с OP_RETURN для уведомления, версия 2 использует мультисиг-скрипт (bloom-multisig) с OP_RETURN, а версии 3 и 4 просто используют мультисиг-скрипт (cfilter-multisig). Таким образом, механизмы, обсуждаемые в этой статье, включая изученные криптографические методы, применимы ко всем четырем версиям. На сегодняшний день реализация PayNym в кошельках Samourai Wallet и Sparrow использует первую версию BIP47.
## Сводка:

1- Проблема повторного использования адресов.

2- Принципы BIP47 и PayNym.

3- Учебные пособия: Использование PayNym.

- Создание транзакции BIP47 с помощью Samourai Wallet.
- Создание транзакции BIP47 с помощью Sparrow Wallet.

4- Механизм работы BIP47.

- Повторно используемый платежный код.
- Криптографический метод: обмен ключами Диффи-Хеллмана, основанный на эллиптических кривых (ECDH).
- Транзакция уведомления.
- Создание транзакции уведомления.
- Получение транзакции уведомления.
- Платежная транзакция BIP47.
- Получение платежа BIP47 и вывод приватного ключа.
- Возврат платежа BIP47.

5- Производные использования PayNym.

6- Мое личное мнение о BIP47.

## Проблема повторного использования адресов.

Адрес для получения используется для получения биткойнов. Он генерируется из публичного ключа путем его хеширования и применения специфического формата. Таким образом, это позволяет создать новое условие расходования монеты для изменения ее владельца.

> Чтобы узнать больше о генерации адреса для получения, рекомендую прочитать последнюю часть этой статьи: Биткойн-кошелек - выдержка из [ebook Bitcoin Démocratisé 2](https://www.pandul.fr/post/le-portefeuille-bitcoin-extrait-ebook-bitcoin-d%C3%A9mocratis%C3%A9-2#viewer-epio7).

Кроме того, вы, вероятно, уже слышали от знающего биткойнера, что адреса для получения предназначены для однократного использования, и что вы должны генерировать новый адрес для каждого нового входящего платежа в ваш кошелек. Хорошо, но почему?
В основном, повторное использование адреса напрямую не подвергает ваши средства опасности. Использование криптографии на эллиптических кривых позволяет вам доказать сети, что вы владеете приватным ключом, не раскрывая этот ключ. Таким образом, вы можете заблокировать несколько разных UTXO (Unspent Transaction Outputs) на одном адресе и тратить их в разное время. Если вы не раскрываете приватный ключ, ассоциированный с этим адресом, никто не сможет получить доступ к вашим средствам. Проблема повторного использования адреса более связана с конфиденциальностью.

Как упоминалось во введении, прозрачность и распределенность сети Bitcoin означают, что любой пользователь с доступом к узлу может наблюдать за транзакциями платежной системы. В результате они могут видеть разные балансы адресов. Тогда Сатоши Накамото упомянул возможность генерации новых пар ключей, а следовательно, новых адресов, для каждого нового входящего платежа в кошелек. Целью было бы иметь дополнительный брандмауэр в случае ассоциации между личностью пользователя и одной из их пар ключей.

Сегодня, при наличии компаний по анализу цепочек и развитии KYC (Know Your Customer), использование пустых адресов больше не является дополнительным брандмауэром, а обязанностью для любого, кто хоть немного заботится о своей конфиденциальности.

Стремление к конфиденциальности не является удобством или фантазией максималистов биткойна. Это конкретный параметр, который напрямую влияет на вашу личную безопасность и безопасность ваших средств. Чтобы помочь вам понять это, вот очень конкретный пример:
- Боб покупает Биткойн через метод средневзвешенной стоимости (Dollar Cost Averaging, DCA), что означает, что он приобретает небольшое количество Биткойна на регулярной основе, чтобы усреднить цену входа. Боб систематически отправляет купленные средства на один и тот же адрес получения. Он покупает 0.01 Биткойна каждую неделю и отправляет его на этот же адрес. Через два года Боб накопил целый Биткойн на этом адресе.
- Пекарь на углу принимает платежи в Биткойнах. Взволнованный возможностью тратить Биткойны, Боб идет купить свою багет в сатоши. Для оплаты он использует средства, заблокированные на его адресе. Теперь его пекарь знает, что у него есть Биткойн. Это значительное количество может привлечь зависть, и Боб потенциально рискует физической атакой в будущем.

Повторное использование адреса позволяет наблюдателю сделать неопровержимую связь между различными UTXO и иногда между вашей личностью и всем вашим кошельком.
Вот почему большинство программного обеспечения для Биткойн-кошельков автоматически генерирует новый адрес получения, когда вы нажимаете на кнопку "Получить". Для обычных пользователей привыкание к использованию новых адресов не является большим неудобством. Однако для онлайн-бизнеса, биржи или кампании по сбору пожертвований это ограничение может быстро стать непосильным.
Существует множество решений для этих организаций. Каждое из них имеет свои преимущества и недостатки, но на сегодняшний день, как мы увидим позже, BIP47 действительно выделяется среди прочих.

Проблема повторного использования адресов в Биткойне далеко не незначительна. Как вы можете видеть на графике ниже, взятом с сайта oxt.me, общий процент повторного использования адресов пользователями Биткойна в настоящее время составляет 52%:
График с OXT.me, показывающий эволюцию общего процента повторного использования адресов в сети Биткойн.

![изображение](assets/2.webp)

Кредит: OXT

Большинство этих повторных использований происходит на биржах, которые по причинам эффективности и удобства многократно используют один и тот же адрес. На сегодняшний день BIP47 был бы лучшим решением для преодоления этого явления среди бирж. Это помогло бы снизить общий процент повторного использования адресов без создания слишком больших неудобств для этих сущностей.

Эта глобальная мера по всей сети особенно актуальна в данном случае. Действительно, повторное использование адресов является проблемой не только для лица, занимающегося этой практикой, но и для любого, кто совершает с ним транзакции. Потеря конфиденциальности в Биткойне действует как вирус, распространяясь от пользователя к пользователю. Изучение глобальной меры по всем транзакциям в сети позволяет нам понять масштаб этого явления.

## Принципы BIP47 и PayNym.

BIP47 направлен на предоставление простого способа получения множественных платежей без повторного использования адреса. Его работа основана на использовании повторно используемого платежного кода.

Таким образом, множество отправителей могут отправлять множество платежей на один повторно используемый платежный код другого пользователя, без необходимости для получателя предоставлять новый пустой адрес для каждой новой транзакции.

Пользователь может свободно делиться своим платежным кодом (в социальных сетях, на своем сайте...) без риска потери конфиденциальности, в отличие от обычного адреса получения или публичного ключа.
Для осуществления обмена оба пользователя должны иметь Биткойн-кошелек с реализацией BIP47, такой как PayNym в Samourai Wallet или Sparrow Wallet. Ассоциация платежных кодов двух пользователей установит секретный канал между ними. Для надлежащего установления этого канала отправитель должен совершить транзакцию в блокчейне Биткойна: уведомительную транзакцию (об этом я расскажу подробнее позже).

Ассоциация платежных кодов двух пользователей генерирует общие секреты, которые сами генерируют большое количество уникальных адресов получения Биткойна (точно 2^32). Таким образом, на самом деле платеж с BIP47 не отправляется на платежный код, а на совершенно обычные адреса, полученные из платежных кодов участвующих сторон.
Платежный код действует как виртуальный идентификатор, производный от семени кошелька. В структуре производных HD-кошельков платежный код находится на глубине 3, на уровне учетной записи кошелька.
![image](assets/3.webp)

Его цель производства отмечена как 47' (0x8000002F) в соответствии с BIP47. Например, путь производства для повторно используемого платежного кода будет:

> m/47'/0'/0'/

Чтобы дать вам представление о том, как выглядит платежный код, вот мой:

> PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5

Он также может быть закодирован как QR-код для облегчения коммуникации:

![image](assets/4.webp)

Что касается PayNym Bots, тех роботов, которых вы видите в Twitter, они являются просто визуальными представлениями вашего платежного кода, созданными кошельком Samourai. Они генерируются с использованием хеш-функции, что делает их почти уникальными. Вот мой с его идентификатором:

> +throbbingpond8B1

![image](assets/5.webp)

Эти боты не имеют никакой реальной технической пользы. Вместо этого они облегчают взаимодействие между пользователями, создавая виртуальную визуальную идентичность.

Для пользователя процесс совершения платежа по BIP47 с использованием реализации PayNym крайне прост. Давайте представим, что Алиса хочет отправить платежи Бобу:

1. Боб делится своим QR-кодом или непосредственно своим повторно используемым платежным кодом. Он может разместить его на своем веб-сайте, на своих различных публичных социальных сетях или отправить Алисе другим способом связи.
2. Алиса открывает свое программное обеспечение Samourai или Sparrow и сканирует или вставляет платежный код Боба.
3. Алиса связывает свой PayNym с PayNym Боба ("Follow" по-английски). Эта операция выполняется вне цепочки и остается полностью бесплатной.

4. Алиса соединяет свой PayNym с PayNym Боба ("Connect" по-английски). Эта операция выполняется "в цепочке". Алиса должна оплатить комиссию за майнинг транзакции, а также фиксированную комиссию в 15 000 сатоши за услугу на Samourai. Комиссии за услуги не взимаются на Sparrow. Этот шаг называется транзакцией уведомления.

5. Как только транзакция уведомления подтверждена, Алиса может создать BIP47 платежную транзакцию Бобу. Ее кошелек автоматически генерирует новый пустой адрес получения, ключ к которому имеет только Боб.

Выполнение транзакции уведомления, то есть соединение ее PayNym, является обязательным условием для совершения платежей BIP47. Однако, как только это сделано, отправитель может совершать множество платежей получателю (точно 2^32) без необходимости выполнения новой транзакции уведомления.

Вы могли заметить, что существуют две разные операции для связывания PayNyms вместе: "follow" и "connect". Операция соединения ("connect") соответствует транзакции уведомления BIP47, которая является просто биткойн-транзакцией с передачей определенной информации через выход OP_RETURN. Таким образом, это помогает установить зашифрованную коммуникацию между двумя пользователями для производства общих секретов, необходимых для генерации новых пустых адресов получения.

С другой стороны, операция связывания ("follow" или "relier") позволяет создать связь на Soroban, протоколе зашифрованной коммуникации на основе Tor, специально разработанном командами Samourai.

Подводя итог:
- Связывание двух PayNym ("подписка") является совершенно бесплатным. Это помогает установить зашифрованное общение вне блокчейна, особенно для использования инструментов совместных транзакций Samourai (Stowaway или StonewallX2). Эта операция специфична для PayNym и не описана в BIP47.
- Соединение двух PayNym влечет за собой расходы. Это включает выполнение уведомляющей транзакции для инициации соединения. Стоимость состоит из любых сервисных сборов, комиссий за майнинг транзакций и 546 сатоши, отправляемых на адрес уведомления получателя для информирования их об открытии туннеля. Эта операция связана с BIP47. После завершения отправитель может совершать множество платежей BIP47 получателю.

Для соединения двух PayNym они должны быть уже связаны.

## Учебные пособия: Использование PayNym.

Теперь, когда мы рассмотрели теорию, давайте изучим практику вместе. Идея следующих учебных пособий заключается в том, чтобы связать мой PayNym в моем кошельке Sparrow с моим PayNym в моем кошельке Samourai. Первое учебное пособие показывает, как совершить транзакцию с использованием повторно используемого платежного кода из Samourai в Sparrow, а второе учебное пособие описывает тот же механизм из Sparrow в Samourai.

> Я выполнил эти учебные пособия на Testnet. Это не настоящие биткоины.

### Создание транзакции BIP47 с помощью кошелька Samourai.

Для начала, очевидно, вам нужно приложение кошелька Samourai. Вы можете скачать его напрямую из Google Play Store или с APK-файла, доступного на официальном сайте Samourai.

После инициализации кошелька, если вы еще этого не сделали, запросите ваш PayNym, нажав на плюс (+) в нижнем правом углу, затем на "PayNym".

Первый шаг для совершения платежа BIP47 - получение повторно используемого платежного кода от нашего получателя. Затем мы сможем соединиться с ними и впоследствии связаться:

![видео](assets/6.mp4)

После подтверждения уведомляющей транзакции я могу отправить несколько платежей моему получателю. Каждая транзакция будет автоматически совершаться с новым пустым адресом, ключи от которого есть у получателя. Получателю не нужно предпринимать никаких действий, все расчеты производятся на моей стороне.

Вот как совершить транзакцию BIP47 в кошельке Samourai:

![видео](assets/7.mp4)

### Создание транзакции BIP47 с помощью кошелька Sparrow.

Так же, как и с Samourai, вам, очевидно, нужно иметь программное обеспечение Sparrow. Оно доступно на вашем компьютере. Вы можете скачать его с их [официального сайта](https://sparrowwallet.com/).

Убедитесь в проверке подписи разработчика и целостности загруженного программного обеспечения перед его установкой на вашу машину.

Создайте кошелек и запросите ваш PayNym, нажав на "Показать PayNym" в меню "Инструменты" в верхней панели:

![изображение](assets/8.webp)

Затем вам нужно будет связать и соединить ваш PayNym с PayNym вашего получателя. Для этого введите их повторно используемый платежный код в окно "Найти контакт", подпишитесь на них, а затем выполните уведомляющую транзакцию, нажав на "Связать контакт":

![изображение](assets/9.webp)

После подтверждения уведомляющей транзакции вы можете отправлять платежи на повторно используемый платежный код. Вот как это сделать:

![видео](assets/10.mp4)

Теперь, когда мы смогли изучить практическую сторону реализации PayNym BIP47, давайте посмотрим, как работают все эти механизмы и какие криптографические методы используются.
Для изучения механизмов BIP47 необходимо понимать структуру иерархического детерминированного (HD) кошелька, механизмы получения дочерних пар ключей, а также принципы криптографии на эллиптических кривых. К счастью, всю необходимую информацию для понимания этой части вы можете найти в моем блоге:
- [Понимание путей производных Bitcoin кошелька](https://www.pandul.fr/post/comprendre-les-chemins-de-d%C3%A9rivation-d-un-portefeuille-bitcoin)

- [Bitcoin кошелек - выдержка из электронной книги Bitcoin Democratized 2](https://www.pandul.fr/post/le-portefeuille-bitcoin-extrait-ebook-bitcoin-d%C3%A9mocratis%C3%A9-2)

### Повторно используемый платежный код.

Как объясняется во второй части этой статьи, повторно используемый платежный код находится на третьем уровне иерархии HD кошелька. Он в некотором роде сравним с xpub, как по своему расположению и структуре, так и по своей роли.

Вот различные части, составляющие 80-байтовый платежный код:

- Байт 0: Версия. Если используется первая версия BIP47, этот байт будет равен 0x01.

- Байт 1: Битовое поле. Это пространство зарезервировано для предоставления дополнительных указаний в случае специфического использования. Если просто использовать PayNym, этот байт будет равен 0x00.

- Байт 2: Четность y. Этот байт указывает 0x02 или 0x03 в зависимости от четности (четное или нечетное число) значения координаты y нашего публичного ключа. Для получения дополнительной информации об этой практике, пожалуйста, прочитайте шаг 1 раздела "производство адресов" этой статьи.

- С байта 3 по байт 34: Значение x. Эти байты указывают координату x нашего публичного ключа. Конкатенация x и четности y дает нам наш сжатый публичный ключ.

- С байта 35 по байт 66: Код цепи. Это пространство зарезервировано для кода цепи, связанного с упомянутым публичным ключом.

- С байта 67 по байт 79: Заполнение. Это пространство зарезервировано для возможных будущих разработок. Для версии 1 мы просто заполняем его нулями, чтобы достичь 80 байтов, что является размером данных для вывода OP_RETURN.

Вот шестнадцатеричное представление моего повторно используемого платежного кода, представленного в предыдущем разделе, с цветами, соответствующими вышеупомянутым байтам:
Далее, вам также нужно добавить префиксный байт "P", чтобы быстро идентифицировать, что мы имеем дело с платежным кодом. Этот байт равен 0x47.

> 0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000

Наконец, мы вычисляем контрольную сумму этого платежного кода, используя HASH256, что означает двойное хеширование функцией SHA256. Мы извлекаем первые четыре байта этого дайджеста и конкатенируем их в конце (на розовом фоне).
Код платежа готов, теперь нам просто нужно конвертировать его в Base 58:

> PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5

Как вы можете видеть, эта конструкция тесно напоминает структуру расширенного публичного ключа типа "xpub".

В процессе получения нашего платежного кода мы использовали сжатый публичный ключ и код цепи. Эти два элемента являются результатом детерминированного и иерархического производства от семени кошелька, следуя следующему пути производства: m/47'/0'/0'/
Конкретно, чтобы получить публичный ключ и код цепи повторно используемого платежного кода, мы вычислим мастер-приватный ключ из семени, затем производим пару дочерних ключей с индексом 47 + 2^31 (усиленное производство). Затем мы производим еще две пары дочерних ключей с индексом 2^31 (усиленное производство).

> Если вы хотите узнать больше о производстве дочерних пар ключей в иерархическом детерминированном биткойн-кошельке, я рекомендую пройти CRYPTO301.

### Криптографический метод: Обмен ключами Эллиптической кривой Диффи-Хеллмана (ECDH).

Криптографический метод, используемый в основе BIP47, это ECDH (Обмен ключами Эллиптической кривой Диффи-Хеллмана). Этот протокол является вариантом классического обмена ключами Диффи-Хеллмана.

Диффи-Хеллман, в его первой версии, это протокол согласования ключей, представленный в 1976 году, который позволяет двум сторонам, каждая из которых имеет пару публичного и приватного ключей, определить общий секрет, обмениваясь информацией по незащищенному каналу связи.

![изображение](assets/11.webp)

Этот общий секрет (красный ключ) затем может быть использован для других задач. Обычно этот общий секрет может быть использован для шифрования и дешифрования коммуникации по незащищенной сети:

![изображение](assets/12.webp)

Для достижения этого обмена Диффи-Хеллман использует модульную арифметику для вычисления общего секрета. Вот упрощенное объяснение того, как это работает:

- Алиса и Боб договариваются о общем цвете, в данном случае, желтом. Этот цвет известен всем. Это публичная информация.

- Алиса выбирает секретный цвет, в данном случае, красный. Она смешивает два цвета, в результате получается оранжевый.

- Боб выбирает секретный цвет, в данном случае, бирюзово-синий. Он смешивает два цвета, в результате получается небесно-голубой.

- Алиса и Боб могут обменяться полученными цветами: оранжевым и небесно-голубым. Этот обмен может произойти по незащищенной сети и может быть наблюдаемым злоумышленниками.

- Алиса смешивает небесно-голубой цвет, полученный от Боба, со своим секретным цветом (красным). Она получает коричневый.

- Боб смешивает оранжевый цвет, полученный от Алисы, со своим секретным цветом (бирюзово-синим). Он также получает коричневый.

![изображение](assets/13.webp)
> z равно A в степени b по модулю p:
> z = A^b % p

- Напомним, что A = g^a % p. Следовательно:

  > z = A^b % p
  > z = (g^a)^b % p
  >
  > Согласно правилам возведения в степень:
  >
  > (x^n)^m = x^nm
  >
  > Следовательно:
  >
  > z = g^ab % p

Таким образом, и Алиса, и Боб получают одно и то же значение z, которое и будет их общим секретом. Это значение z (представленное коричневым цветом) невозможно вычислить для атакующего, не зная секретных чисел a и b, даже если он знает A, B, p и g. Это основная идея обмена ключами Диффи-Хеллмана, позволяющая двум сторонам безопасно обмениваться секретным ключом даже через незащищенный канал связи.
z равно A в степени b по модулю p:
> z = A^b % p

Следовательно:

> z = (g^a)^b % p
> z = g^(ab) % p
> z = g^(ba) % p

Благодаря распределительному свойству оператора модуля, Алиса и Боб находят точно такое же значение для z. Это число представляет их общий секрет, который эквивалентен цвету коричневого в предыдущем объяснении. Они могут использовать этот общий секрет для шифрования коммуникации между собой по незащищенной сети.

![Диаграмма технической операции Диффи-Хеллмана](assets/14.webp)

Атакующий, владеющий p, g, A и B, не сможет вычислить a, b или z. Выполнение этой операции потребовало бы обращения экспоненциации, что невозможно сделать иначе, как путем попыток всех возможностей по одной, поскольку мы работаем с конечным полем. Это было бы эквивалентно вычислению дискретного логарифма, который является обратным экспоненциации в циклической конечной группе.

Таким образом, до тех пор, пока мы выбираем достаточно большие значения для a, b и p, Диффи-Хеллман безопасен. Обычно, с параметрами в 2,048 бит (число с 600 цифрами в десятичной системе), проверка всех возможностей для a и b была бы непрактичной. На сегодняшний день, с числами такого размера, алгоритм считается безопасным.

Именно здесь лежит основной недостаток протокола Диффи-Хеллмана. Для обеспечения безопасности алгоритм должен использовать большие числа. В результате, теперь предпочтение отдается алгоритму ECDH, который является вариантом Диффи-Хеллмана, использующим алгебраическую кривую, а именно эллиптическую кривую. Это позволяет нам работать с гораздо меньшими числами, сохраняя при этом эквивалентную безопасность, тем самым сокращая необходимые вычислительные и хранилищные ресурсы.

Общий принцип алгоритма остается тем же. Однако, вместо использования случайного числа a и числа A, вычисленного из a с использованием модульной экспоненциации, мы будем использовать пару ключей, установленных на эллиптической кривой. Вместо опирания на распределительное свойство оператора модуля, мы будем использовать групповой закон на эллиптических кривых, а именно ассоциативность этого закона.
Если вы не знаете, как работают приватные и публичные ключи на эллиптической кривой, я объясню основы этого метода в первых шести частях этой статьи.

Грубо говоря, приватный ключ - это случайное число между 1 и n-1 (где n - порядок кривой), а публичный ключ - это уникальная точка на кривой, определенная приватным ключом через сложение точек и удвоение от генераторной точки, следующим образом:

> K = k·G

Где K - публичный ключ, k - приватный ключ, а G - генераторная точка.

Одно из свойств этой пары ключей заключается в том, что очень легко определить K, если вы знаете k и G, но в настоящее время невозможно определить k, если вы знаете K и G. Это односторонняя функция.

Другими словами, вы можете легко вычислить публичный ключ, если знаете приватный ключ, но невозможно вычислить приватный ключ, если знаете публичный ключ. Эта безопасность снова основана на невозможности вычисления дискретного логарифма.

Мы будем использовать это свойство для адаптации нашего алгоритма Диффи-Хеллмана. Таким образом, принцип работы ECDH следующий:

- Алиса и Боб договариваются о криптографически безопасной эллиптической кривой и ее параметрах. Эта информация является публичной.
- Алиса генерирует случайное число ka, которое будет ее приватным ключом. Этот приватный ключ должен оставаться в секрете. Она определяет свой публичный ключ Ka, прибавляя и удваивая точки на выбранной эллиптической кривой.
> Ka = ka·G

- Боб также генерирует случайное число kb, которое будет его приватным ключом. Он вычисляет соответствующий публичный ключ Kb.

> Kb = kb·G

- Алиса и Боб обмениваются своими публичными ключами Ka и Kb через незащищенную публичную сеть.

- Алиса вычисляет точку (x, y) на кривой, применяя свой приватный ключ ka к публичному ключу Боба Kb.

> (x, y) = ka·Kb

- Боб вычисляет точку (x, y) на кривой, применяя свой приватный ключ kb к публичному ключу Алисы Ka.

> (x, y) = kb·Ka

- Алиса и Боб получают одну и ту же точку на эллиптической кривой. Общим секретом будет x-координата этой точки.

Они действительно получают один и тот же общий секрет, потому что:

> (x, y) = ka·Kb = ka·kb·G = kb·ka·G = kb·Ka

Потенциальный атакующий, наблюдающий за незащищенной публичной сетью, может получить только публичные ключи каждой стороны и параметры выбранной кривой. Как было объяснено ранее, эти две части информации в одиночку не позволяют определить приватные ключи, так что атакующий не может получить доступ к секрету.
ECDH — это алгоритм, позволяющий обмен ключами. Он часто используется вместе с другими криптографическими методами для определения протокола. Например, ECDH используется в ядре TLS (Transport Layer Security), протокола шифрования и аутентификации, используемого для транспортного слоя интернета. TLS использует ECDHE для обмена ключами, вариант ECDH, где ключи являются эфемерными, чтобы обеспечить постоянную конфиденциальность. Помимо ECDHE, TLS также использует алгоритм аутентификации, например ECDSA, алгоритм шифрования, например AES, и хеш-функцию, например SHA256.

TLS определяет "s" в "https" и маленький замочек, который вы видите в верхнем левом углу вашего интернет-браузера, что гарантирует зашифрованное общение. Таким образом, вы в настоящее время используете ECDH, читая эту статью, и, вероятно, используете его ежедневно, даже не осознавая этого.

### Транзакция уведомления.

Как мы узнали в предыдущем разделе, ECDH — это вариант обмена Диффи-Хеллмана, включающий пары ключей, установленные на эллиптической кривой. К счастью, у нас есть множество пар ключей, соответствующих этому стандарту, в наших биткойн-кошельках!

Идея состоит в том, чтобы использовать пары ключей из иерархически детерминированных биткойн-кошельков обеих сторон для установления общих и эфемерных секретов между ними. В BIP47 вместо этого используется ECDHE (Эфемерный Эллиптический Кривой Диффи-Хеллман).

Изначально ECDHE используется в BIP47 для передачи платежного кода отправителя получателю. Это знаменитая транзакция уведомления. Для использования BIP47 обе стороны (отправитель, который отправляет платежи, и получатель, который получает платежи) должны знать платежный код друг друга. Это необходимо для вывода эфемерных публичных ключей и, следовательно, специализированных адресов получения.
Перед этим обменом отправитель логически уже знает платежный код получателя, поскольку он мог получить его вне блокчейна, например, с их веб-сайта или социальных сетей. Однако получатель не обязательно знает платежный код отправителя. Его необходимо передать, иначе они не смогут получить свои эфемерные ключи и, следовательно, не смогут узнать, где находятся их биткойны, и разблокировать свои средства. Это может быть передано им вне блокчейна, используя другую систему связи, но это создаст проблему, если кошелек будет восстановлен из сида. Действительно, как я уже упоминал, адреса BIP47 не производятся из сида получателя (иначе было бы лучше использовать один из их xpubs напрямую), но являются результатом расчета, включающего как платежный код получателя, так и платежный код отправителя. Поэтому, если получатель потеряет свой кошелек и попытается восстановить его из своего сида, ему обязательно потребуются все платежные коды людей, которые отправили ему биткойны через BIP47.

Было бы возможно использовать BIP47 без этой уведомляющей транзакции, но каждому пользователю нужно было бы сохранить платежные коды своих коллег. Эта ситуация останется неуправляемой до тех пор, пока не будет найден простой и надежный способ создания, хранения и обновления этих резервных копий. Поэтому уведомляющая транзакция почти обязательна в текущем состоянии вещей.

Помимо своей роли резервного копирования платежных кодов, как следует из названия, эта транзакция также служит уведомлением для получателя. Она информирует их клиент о том, что туннель только что был открыт.

Прежде чем объяснять более подробно техническое функционирование уведомляющей транзакции, я хотел бы немного поговорить о модели конфиденциальности. Действительно, модель конфиденциальности BIP47 оправдывает определенные меры предосторожности, принимаемые при создании этой исходной транзакции.

Сам по себе платежный код не представляет прямой угрозы для конфиденциальности. В отличие от классической модели Bitcoin, которая позволяет нарушать поток информации между личностью пользователя и транзакциями, особенно путем сохранения анонимности публичных ключей, платежный код может быть напрямую связан с личностью. Это не обязательно, но такая связь не опасна.

Действительно, платежный код напрямую не порождает адреса, используемые для получения платежей BIP47. Вместо этого адреса получаются путем применения ECDHE между дочерними ключами платежных кодов обеих сторон.

Поэтому сам по себе платежный код не представляет прямой угрозы для конфиденциальности, поскольку только уведомляющий адрес производится из него. Из этого можно сделать некоторые выводы, но обычно нельзя знать, с кем вы совершаете транзакции.

Поэтому крайне важно поддерживать строгое разделение между платежными кодами пользователей. В этом отношении начальный этап коммуникации кода является критическим моментом для конфиденциальности платежей, и тем не менее он обязателен для правильной работы протокола. Если один из платежных кодов может быть публично извлечен (например, с веб-сайта), второй код, то есть код отправителя, не должен быть связан с первым.

Например, давайте представим, что я хочу сделать пожертвование с BIP47 мирному протестному движению в Канаде:

- Эта организация напрямую опубликовала свой платежный код на своем веб-сайте или платформах социальных сетей.
- Следовательно, этот код ассоциируется с движением.

- Я извлекаю этот платежный код.

- Прежде чем я смогу отправить им транзакцию, я должен убедиться, что они знают мой личный платежный код, который также ассоциируется с моей личностью, поскольку я использую его для получения транзакций из моих социальных сетей.

Как я могу передать его им? Если я отправлю его им с помощью обычного средства связи, информация может утекать, и меня могут идентифицировать как лицо, поддерживающее мирные движения.
Уведомительная транзакция определенно не единственное решение для секретной передачи платежного кода отправителя, но в настоящее время она идеально выполняет эту роль, применяя несколько уровней безопасности.
На диаграмме ниже красные линии представляют момент, когда поток информации должен быть прерван, а черные стрелки представляют неоспоримые связи, которые могут быть установлены внешним наблюдателем:

![Диаграмма модели конфиденциальности для многоразового платежного кода](assets/15.webp)

На самом деле, для классической модели конфиденциальности Bitcoin часто бывает сложно полностью прервать поток информации между парой ключей и пользователем, особенно при проведении удаленных транзакций. Например, в случае кампании по сбору пожертвований получателю придется раскрыть адрес или публичный ключ на своем веб-сайте или в социальных сетях. Правильное использование BIP47, т.е. с уведомительной транзакцией, решает эту проблему через ECDHE и слой шифрования, который мы изучим.

Очевидно, что классическая модель конфиденциальности Bitcoin все еще наблюдается на уровне эфемерных публичных ключей, полученных из ассоциации двух платежных кодов. Две модели взаимозависимы. Я просто хочу здесь подчеркнуть, что в отличие от классического использования публичного ключа для получения биткоинов, платежный код может быть ассоциирован с идентичностью, потому что информация "Боб совершает транзакцию с Алисой" прерывается в другой момент. Платежный код используется для генерации платежных адресов, но, наблюдая только за блокчейном, невозможно ассоциировать транзакцию BIP47 с использованными для ее совершения платежными кодами.

### Построение уведомительной транзакции.

Теперь давайте посмотрим, как работает эта уведомительная транзакция. Представим, что Алиса хочет отправить средства Бобу, используя BIP47. В моем примере Алиса выступает в роли отправителя, а Боб - в роли получателя. Боб уже опубликовал свой платежный код на своем веб-сайте, поэтому Алиса уже знает платежный код Боба.

1. Алиса вычисляет общий секрет с помощью ECDH:

- Она выбирает пару ключей из своего HD-кошелька, расположенного на другой ветви, чем ее платежный код. Заметьте, что эта пара не должна быть легко ассоциирована с уведомительным адресом Алисы или ее идентичностью (см. предыдущий раздел).
- Алиса выбирает приватный ключ из этой пары. Мы будем называть его "a" (строчная буква).

> a

- Алиса извлекает публичный ключ, ассоциированный с уведомительным адресом Боба. Этот ключ является первым дочерним ключом, производным от платежного кода Боба (индекс 0). Мы будем называть этот публичный ключ "B" (заглавная буква). Приватный ключ, ассоциированный с этим публичным ключом, называется "b" (строчная буква). "B" определяется путем сложения точек и удвоения на эллиптической кривой от "G" (точка генератора) с "b" (приватный ключ).

> B = b·G

- Алиса вычисляет секретную точку "S" (заглавная буква) на эллиптической кривой путем сложения точек и удвоения, применяя свой приватный ключ "a" к публичному ключу Боба "B".

> S = a·B

- Алиса вычисляет коэффициент затемнения "f", который будет использоваться для шифрования ее платежного кода. Для этого она будет генерировать псевдослучайное число с использованием функции HMAC-SHA512. В качестве второго входа для этой функции она использует значение, которое сможет извлечь только Боб: (x), которое является x-координатой ранее вычисленной секретной точки. Первый вход - это (o), что является UTXO, потребляемым в качестве входа для этой транзакции (выход).

> f = HMAC-SHA512(o, x)

2. Алиса конвертирует свой личный платежный код в двоичный формат (бинарный).
3. Она использует этот коэффициент затемнения как ключ для выполнения симметричного шифрования полезной нагрузки своего платежного кода. Алгоритм шифрования, который используется, - это просто XOR. Выполняемая операция аналогична шифру Вернама, также известному как "одноразовый блокнот":
- Сначала Алиса разделяет свой коэффициент затемнения на две части: первые 32 байта называются "f1", а последние 32 байта - "f2". Итак, у нас есть:

> f = f1 || f2

- Алиса вычисляет шифртекст (x') координаты x публичного ключа (x) своего платежного кода и отдельно вычисляет шифртекст (c') своего цепочечного кода (c). "f1" и "f2" действуют как ключи шифрования, и используется операция XOR.

> x' = x XOR f1
>
> c' = c XOR f2

- Алиса заменяет фактические значения абсциссы публичного ключа (x) и цепочечного кода (c) в своем платежном коде зашифрованными значениями (x') и (c').

Прежде чем продолжить техническое описание этой транзакции уведомления, давайте на мгновение обсудим операцию XOR. XOR - это побитовый логический оператор, основанный на булевой алгебре. Для двух битовых операндов он возвращает 1, если соответствующие биты различны, и возвращает 0, если соответствующие биты равны. Вот таблица истинности для XOR на основе значений операндов D и E:

| D   | E   | D XOR E |
| --- | --- | ------- |
| 0   | 0   | 0       |
| 0   | 1   | 1       |
| 1   | 0   | 1       |
| 1   | 1   | 0       |

Например:

> 0110 XOR 1110 = 1000

Или:

> 010011 XOR 110110 = 100101

С использованием ECDH применение XOR в качестве слоя шифрования особенно логично. Во-первых, благодаря этому оператору шифрование является симметричным. Это позволяет получателю расшифровать платежный код с тем же ключом, который использовался для шифрования. Ключ шифрования и расшифровки вычисляется из общего секрета с использованием ECDH.

Эта симметрия обеспечивается свойствами коммутативности и ассоциативности оператора XOR:

- Другие свойства:
  -> D ⊕ D = 0
  -> D ⊕ 0 = D

- Коммутативность:
  D ⊕ E = E ⊕ D

- Ассоциативность:
  D ⊕ (E ⊕ Z) = (D ⊕ E) ⊕ Z = D ⊕ E ⊕ Z

- Симметрия:
  Если: D ⊕ E = L
  Тогда: D ⊕ L = D ⊕ (D ⊕ E) = D ⊕ D ⊕ E = 0 ⊕ E = E
  -> D ⊕ L = E
Далее, данный метод шифрования очень похож на шифр Вернама (Одноразовый блокнот), единственный алгоритм шифрования, известный на сегодняшний день, который обладает безусловной (или абсолютной) безопасностью. Для того чтобы шифр Вернама обладал этой характеристикой, ключ шифрования должен быть абсолютно случайным, иметь такой же размер, как и сообщение, и использоваться только один раз. В используемом здесь методе шифрования для BIP47 ключ действительно имеет такой же размер, как и сообщение, а коэффициент затемнения точно такой же размер, как и конкатенация x-координаты открытого ключа с кодом цепочки платежного кода. Этот ключ шифрования действительно используется только один раз. Однако этот ключ не получен из идеального случайного источника, поскольку он является HMAC. Он скорее псевдослучайный. Поэтому это не шифр Вернама, но метод похож.

Давайте вернемся к нашей конструкции уведомляющей транзакции:

4. В настоящее время у Алисы есть ее платежный код с зашифрованным полезным грузом. Она создаст и транслирует транзакцию, включающую ее открытый ключ "A" в качестве входа, выход на уведомляющий адрес Боба и выход OP_RETURN, состоящий из ее платежного кода с зашифрованным полезным грузом. Эта транзакция является уведомляющей транзакцией.

OP_RETURN - это Opcode, который является скриптом, помечающим выход транзакции Bitcoin как недействительный. Сегодня он используется для трансляции или закрепления информации на блокчейне Bitcoin. Он может хранить до 80 байт данных, которые записываются в цепочку и, следовательно, видны всем другим пользователям.

Как мы видели в предыдущем разделе, Диффи-Хеллман используется для генерации общего секрета между двумя пользователями, общающимися по незащищенной сети, потенциально наблюдаемой атакующими. В BIP47 для общения в сети Bitcoin используется ECDH, которая по своей природе является прозрачной коммуникационной сетью, наблюдаемой многими атакующими. Общий секрет, рассчитанный через обмен ключами Диффи-Хеллмана на эллиптической кривой, затем используется для шифрования секретной информации, которая должна быть передана: платежного кода отправителя (Алисы).

Вот диаграмма, извлеченная из BIP47, которая иллюстрирует то, что мы только что описали:

![Диаграмма Алиса отправляет свой замаскированный платежный код на уведомляющий адрес Боба](assets/16.webp)

Кредит: Reusable Payment Codes for Hierarchical Deterministic Wallets, Justus Ranvier. https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

Если мы сопоставим эту диаграмму с тем, что я описал ранее:

- "Wallet Priv-Key" со стороны Алисы соответствует: a.

- "Child Pub-Key 0" со стороны Боба соответствует: B.
- "Notification Shared Secret" соответствует: f.
- "Masked Payment Code" соответствует зашифрованному платежному коду, т.е. с зашифрованным полезным грузом: x' и c'.

- "Notification Transaction" - это транзакция, которая содержит OP_RETURN.

Давайте повторим шаги, которые мы только что прошли, чтобы выполнить уведомляющую транзакцию:

- Алиса извлекает платежный код и уведомляющий адрес Боба.

- Алиса выбирает UTXO, принадлежащий ей в ее HD-кошельке с соответствующей парой ключей.

- Она рассчитывает секретную точку на эллиптической кривой с использованием ECDH.

- Она использует эту секретную точку для расчета HMAC, который является коэффициентом затемнения.

- Она использует этот коэффициент затемнения для шифрования полезной нагрузки своего личного платежного кода.

- Она использует выход транзакции OP_RETURN для передачи замаскированного платежного кода Бобу.

Чтобы лучше понять его работу, особенно использование OP_RETURN, давайте вместе изучим реальную уведомляющую транзакцию. Я выполнил такую транзакцию на Testnet, которую вы можете найти, кликнув здесь:
Наблюдая за этой транзакцией, мы уже видим, что она имеет один вход и четыре выхода:

- Первый выход - это OP_RETURN, который содержит мой маскированный платежный код.

- Второй выход в 546 сатоши указывает на адрес уведомления получателя.

- Третий выход в 15 000 сатоши представляет собой плату за услугу, так как я использовал кошелек Samourai для создания этой транзакции.

- Четвертый выход в два миллиона сатоши представляет собой сдачу, то есть оставшуюся разницу от моего входа, которая возвращается на другой адрес, принадлежащий мне.

Наибольший интерес для изучения, безусловно, представляет выход 0 с использованием OP_RETURN. Давайте более внимательно посмотрим, что он содержит:

Мы обнаруживаем шестнадцатеричный скрипт выхода:

> 6a4c50010002b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d800000000000000000000000000

В этом скрипте мы можем разделить несколько частей:
Среди опкодов мы можем распознать 0x6a, который относится к OP_RETURN, и 0x4c, который относится к OP_PUSHDATA1. Байт, следующий за этим опкодом, указывает размер следующего за ним полезного груза. Он указывает 0x50, что составляет 80 байт.

Далее следует платежный код с зашифрованным полезным грузом.

Вот мой платежный код, использованный в этой транзакции:

> В формате base 58:
>
> PM8TJQCyt6ovbozreUCBrfKqmSVmTzJ5vjqse58LnBzKFFZTwny3KfCDdwTqAEYVasn11tTMPc2FJsFygFd3YzsHvwNXLEQNADgxeGnMK8Ugmin62TZU
>
> В формате base 16 (HEX):
> 4701000277507c9c17a89cfca2d3af554745d6c2db0e7f6b2721a3941a504933103cc42add94881210d6e752a9abc8a9fa0070e85184993c4f643f1121dd807dd556d1dc000000000000000000000000008604e4db

Если сравнить мой платежный код с OP_RETURN, мы видим, что HRP (в коричневом) и контрольная сумма (в розовом) не передаются. Это нормально, так как эта информация предназначена для людей.
Далее мы можем распознать (зеленым цветом) версию (0x01), битовое поле (0x00) и четность публичного ключа (0x02). И, в конце платежного кода, пустые байты, отмеченные черным (0x00), которые позволяют дополнить общий объем до 80 байтов. Вся эта метадата передается в открытом виде (незашифрованная). Наконец, мы можем заметить, что x-координата публичного ключа (синим цветом) и код цепочки (красным цветом) были зашифрованы. Это составляет полезную нагрузку платежного кода.

### Получение транзакции уведомления.

Теперь, когда Алиса отправила транзакцию уведомления Бобу, давайте посмотрим, как он ее интерпретирует.

Напомним, что Боб должен иметь доступ к платежному коду Алисы. Без этой информации, как мы увидим в следующем разделе, он не сможет получить ключевые пары, созданные Алисой, и, следовательно, не сможет получить доступ к своим биткоинам, полученным с помощью BIP47. Пока что полезная нагрузка платежного кода Алисы зашифрована. Давайте посмотрим вместе, как Боб ее расшифровывает.

1. Боб отслеживает транзакции, которые создают выходы на его уведомляющий адрес.

2. Когда транзакция имеет выход на его уведомляющий адрес, Боб анализирует ее, чтобы увидеть, содержит ли она выход OP_RETURN, соответствующий стандарту BIP47.

3. Если первый байт полезной нагрузки OP_RETURN равен 0x01, Боб начинает поиск возможного общего секрета с ECDH:

- Боб выбирает публичный ключ во входе транзакции. То есть публичный ключ Алисы, обозначенный как "A":

> A = a·G

- Боб выбирает свой приватный ключ "b", связанный с его личным уведомляющим адресом:

> b

- Боб вычисляет секретную точку "S" (общий секрет ECDH) на эллиптической кривой, добавляя и удваивая точки, применяя свой приватный ключ "b" к публичному ключу Алисы "A":

> S = b·A

- Боб определяет коэффициент затемнения "f", который позволит ему расшифровать полезную нагрузку платежного кода Алисы. Так же, как Алиса рассчитала его ранее, Боб найдет "f", применив HMAC-SHA512 к (x) значению x-координаты секретной точки "S" и к (o) UTXO, потребленному в качестве входа в этой транзакции уведомления:

> f = HMAC-SHA512(o, x)

4. Боб интерпретирует данные в OP_RETURN транзакции уведомления как платежный код. Он просто расшифровывает полезную нагрузку этого потенциального платежного кода, используя коэффициент затемнения "f".

- Боб разделяет коэффициент затемнения "f" на две части: первые 32 байта "f" будут "f1", а последние 32 байта будут "f2".
- Боб расшифровывает зашифрованное значение x-координаты (x') публичного ключа платежного кода Алисы:

> x = x' XOR f1

- Боб расшифровывает зашифрованное значение кода цепочки (c') платежного кода Алисы:

> c = c' XOR f2

5. Боб проверяет, является ли значение публичного ключа платежного кода Алисы частью группы secp256k1. Если да, он интерпретирует его как действительный платежный код. В противном случае он игнорирует транзакцию.

Теперь, когда Боб знает платежный код Алисы, она может отправить ему до 2^32 платежей, не нуждаясь в повторении транзакции уведомления, как это было сделано ранее.

Почему это работает? Как Боб может определить тот же коэффициент затемнения, что и Алиса, и расшифровать ее платежный код? Давайте подробнее рассмотрим процесс ECDH на основе того, что мы только что описали.
Во-первых, мы имеем дело с симметричным шифрованием. Это означает, что ключ шифрования и ключ дешифрования имеют одно и то же значение. В данном случае ключ в уведомлении транзакции является скрывающим множителем (f = f1 || f2). Алисе и Бобу необходимо получить одно и то же значение для f, не передавая его напрямую, так как атакующий мог бы перехватить его и расшифровать секретную информацию.
Этот скрывающий множитель получается путем применения HMAC-SHA512 к двум значениям: x-координате секретной точки и использованному UTXO во входе транзакции. Следовательно, Бобу необходимо иметь эти две части информации, чтобы расшифровать платежный код Алисы.

Для входного UTXO Боб может просто извлечь его, наблюдая за уведомлением транзакции. Для секретной точки Бобу придется использовать ECDH.

Как видно в разделе о Диффи-Хеллмане, обмениваясь своими соответствующими открытыми ключами и секретно применяя свои приватные ключи к открытому ключу другого, Алиса и Боб могут найти конкретную и секретную точку на эллиптической кривой. Уведомительная транзакция основана на этом механизме:

> Пара ключей Боба:
>
> B = b·G
>
> Пара ключей Алисы:
>
> A = a·G
>
> Для секретной точки S (x,y):
>
> S = a·B = a·b·G = b·a·G = b·A

![Диаграмма генерации общего секрета с ECDHE](assets/19.webp)
Теперь, когда Боб знает платежный код Алисы, он сможет обнаруживать ее платежи BIP47 и генерировать приватные ключи, блокирующие полученные биткоины.
![Боб интерпретирует уведомительную транзакцию Алисы](assets/20.webp)

Авторство: Reusable Payment Codes for Hierarchical Deterministic Wallets, Justus Ranvier. https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

Если сопоставить эту диаграмму с тем, что я описал вам ранее:

- "Wallet Pub-Key" со стороны Алисы соответствует: A.

- "Child Priv-Key 0" со стороны Боба соответствует: b.

- "Notification Shared Secret" соответствует: f.

- "Masked Payment Code" соответствует маскированному платежному коду Алисы, т.е. с зашифрованным полезным грузом: x' и c'.

- "Notification Transaction" - это транзакция, содержащая OP_RETURN.

Позвольте мне подытожить шаги, которые мы только что рассмотрели вместе, чтобы получить и интерпретировать уведомительную транзакцию:

- Боб мониторит выходы транзакций на свой уведомительный адрес.

- Когда он обнаруживает одну, он извлекает информацию, содержащуюся в OP_RETURN.

- Боб выбирает входной открытый ключ и вычисляет секретную точку, используя ECDH.

- Он использует эту секретную точку для вычисления HMAC, который является скрывающим множителем.

- Он использует этот скрывающий множитель для расшифровки платежного кода Алисы, содержащегося в OP_RETURN.

### Платежная транзакция BIP47.

Теперь давайте изучим процесс платежа с BIP47. Чтобы напомнить вам текущее состояние ситуации:

- Алиса знает платежный код Боба, который она просто извлекла с его веб-сайта.

- Боб знает платежный код Алисы благодаря уведомительной транзакции.

- Алиса совершит первоначальный платеж Бобу. Она может совершать множество таких платежей тем же способом.

Прежде чем объяснять вам этот процесс, я считаю важным напомнить вам, с какими индексами мы сейчас работаем:

Мы описываем путь производного кода платежа следующим образом: m/47'/0'/0'/. 

Следующая глубина распределяет индексы следующим образом:
- Первая обычная (не усиленная) пара ключей используется для генерации адреса уведомлений, о котором мы говорили в предыдущем разделе: m/47'/0'/0'/0/.
- Обычные пары дочерних ключей используются в ECDH для генерации адресов для получения платежей BIP47, как мы увидим в этом разделе: m/47'/0'/0'/ от 0 до 2,147,483,647/.

- Усиленные пары дочерних ключей являются эфемерными платежными кодами: m/47'/0'/0'/ от 0' до 2,147,483,647'/.
  Каждый раз, когда Алиса хочет отправить платеж Бобу, она генерирует новый уникальный пустой адрес, снова благодаря протоколу ECDH:
- Алиса выбирает первый приватный ключ, полученный из её личного многоразового платежного кода:

> a

- Алиса выбирает первый неиспользованный публичный ключ, полученный из платежного кода Боба. Этот публичный ключ мы будем называть "B". Он ассоциирован с приватным ключом "b", который известен только Бобу.

> B = b·G

- Алиса вычисляет секретную точку "S" на эллиптической кривой, добавляя и удваивая точки, применяя свой приватный ключ "a" к публичному ключу Боба "B":

> S = a·B

- Из этой секретной точки Алиса будет вычислять общий секрет "s" (в нижнем регистре). Для этого она выбирает x-координату секретной точки "S", называемую "Sx", и передает это значение в функцию хеширования SHA256.

> s = SHA256(Sx)

Не доверяйте. Проверяйте! Если вы хотите понять основные принципы функции хеширования, вы найдете необходимую информацию в этой статье. И если вы не доверяете NIST (и вы правы), и хотите подробно понять, как работает SHA256, я объясняю все в этой статье на французском языке.

- Алиса использует этот общий секрет "s" для вычисления адреса для получения биткойн-платежей. Сначала она проверяет, что "s" находится в пределах порядка кривой secp256k1. Если нет, она увеличивает индекс публичного ключа Боба для получения другого общего секрета.

- Во-вторых, она вычисляет публичный ключ "K0", добавляя точки "B" и "s·G" на эллиптической кривой. Другими словами, Алиса добавляет публичный ключ, полученный из платежного кода Боба "B", с другой точкой, вычисленной на эллиптической кривой путем добавления и удвоения точек с общим секретом "s" от генераторной точки кривой secp256k1 "G". Эта новая точка представляет собой публичный ключ, и мы называем его "K0":

> K0 = B + s·G

- Имея этот публичный ключ "K0", Алиса может получить пустой адрес для получения в стандартном формате (например, SegWit V0 в Bech32).

Как только у Алисы появляется этот адрес для получения "K0", принадлежащий Бобу, она может составить стандартную биткойн-транзакцию, выбрав UTXO, который принадлежит ей на другой ветке её HD-кошелька, и отправив его на адрес "K0" Боба.

![Алиса отправляет биткойны с BIP47 Бобу](assets/21.webp)

Кредит: Многоразовые платежные коды для иерархически детерминированных кошельков, Justus Ranvier. https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki
Если мы сопоставим эту диаграмму с тем, что я описал вам ранее:

- "Child Priv-Key" с стороны Алисы соответствует: a.
- "Child Pub-Key 0" с стороны Боба соответствует: B.
- "Payment Secret 0" соответствует: s.
- "Платежный Публичный Ключ 0" соответствует: K0.
Давайте подведем итог шагам, которые мы только что прошли вместе, чтобы отправить платеж по BIP47:

- Алиса выбирает первый производный дочерний закрытый ключ из своего личного платежного кода.
- Она вычисляет секретную точку на эллиптической кривой, используя ECDH из первого неиспользованного производного дочернего публичного ключа из платежного кода Боба.
- Она использует эту секретную точку для вычисления общего секрета с помощью SHA256.
- Она использует этот общий секрет для вычисления новой секретной точки на эллиптической кривой.
- Она добавляет эту новую секретную точку к публичному ключу Боба.
- Она получает новый эфемерный публичный ключ, для которого только Боб имеет соответствующий закрытый ключ.
- Алиса может отправить обычную транзакцию Бобу на производный эфемерный адрес получения.

Если она захочет сделать второй платеж, она повторит вышеуказанные шаги, за исключением того, что выберет второй производный публичный ключ из платежного кода Боба. То есть следующий неиспользованный ключ. Тогда у нее будет второй адрес получения, принадлежащий Бобу, "K1".

![Алиса выводит три адреса получения BIP47 для Боба](assets/22.webp)

Кредит: Повторно используемые платежные коды для иерархически детерминированных кошельков, Justus Ranvier. https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

Она может продолжать таким образом и выводить до 2^32 пустых адресов, принадлежащих Бобу.

С внешней точки зрения, наблюдая за блокчейном Bitcoin, теоретически невозможно отличить платеж BIP47 от обычного платежа. Вот пример транзакции платежа BIP47 в Testnet:

https://blockstream.info/testnet/tx/94b2e59510f2e1fa78411634c98a77bbb638e28fb2da00c9f359cd5fc8f87254

TXID:

> 94b2e59510f2e1fa78411634c98a77bbb638e28fb2da00c9f359cd5fc8f87254

Это выглядит как обычная транзакция с использованным входом, платежным выходом в 210,000 сатоши и сдачей.

![Транзакция Bitcoin с платежом BIP47](assets/23.webp)

Кредит: https://blockstream.info/

### Получение платежа BIP47 и вывод закрытого ключа.

Алиса только что совершила свой первый платеж на пустой адрес BIP47, принадлежащий Бобу. Теперь давайте посмотрим, как Боб получает этот платеж. Мы также увидим, почему Алиса не имеет доступа к закрытому ключу адреса, который она только что сгенерировала, и как Боб извлекает этот ключ, чтобы потратить только что полученные биткоины.

Как только Боб получает уведомление о транзакции от Алисы, он выводит публичный ключ BIP47 "K0" еще до того, как она отправит какой-либо платеж на него. Таким образом, он наблюдает за любым платежом на ассоциированный адрес. Фактически, он сразу выводит несколько адресов, за которыми он будет наблюдать (K0, K1, K2, K3...). Вот как он выводит этот публичный ключ "K0":

- Боб выбирает первый дочерний закрытый ключ, производный от его платежного кода. Этот закрытый ключ называется "b". Он ассоциирован с публичным ключом "B", который Алиса использовала на предыдущем шаге:

> b

- Боб выбирает первый производный публичный ключ Алисы из ее платежного кода. Этот ключ называется "A". Он ассоциирован с закрытым ключом "a", который Алиса использовала в своих расчетах, и о котором только Алиса знает. Боб может выполнить этот процесс, потому что он знает платежный код Алисы, который был передан ему с уведомлением о транзакции.

> A = a·G
- Боб вычисляет секретную точку "S", прибавляя и удваивая точки на эллиптической кривой, применяя свой приватный ключ "b" к публичному ключу Алисы "A". Здесь мы используем ECDH, что гарантирует, что эта точка "S" будет одинаковой как для Боба, так и для Алисы.
> S = b·A

- Так же, как и Алиса, Боб изолирует x-координату этой точки "S". Мы назвали это значение "Sx". Он пропускает это значение через функцию SHA256, чтобы найти общий секрет "s" (в нижнем регистре).

> s = SHA256(Sx)

- Так же, как и Алиса, Боб вычисляет точку "s·G" на эллиптической кривой. Затем он добавляет эту секретную точку к своему публичному ключу "B". Таким образом, он получает новую точку на эллиптической кривой, которую он интерпретирует как публичный ключ "K0":

> K0 = B + s·G

Как только у Боба появляется этот публичный ключ "K0", он может вывести соответствующий приватный ключ, чтобы потратить свои биткоины. Только он может сгенерировать этот номер.

- Боб добавляет свой производный дочерний приватный ключ "b" из своего личного платежного кода. Только он может получить значение "b". Затем он добавляет "b" к общему секрету "s", чтобы получить k0, приватный ключ K0:

> k0 = b + s
> Благодаря закону группы эллиптической кривой, Боб получает точно тот приватный ключ, который соответствует публичному ключу, используемому Алисой. Таким образом, у нас есть:
> K0 = k0·G

![Боб генерирует свои приемные адреса BIP47](assets/24.webp)

Кредит: Reusable Payment Codes for Hierarchical Deterministic Wallets, Justus Ranvier. https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

Если сопоставить эту схему с тем, что я описал вам ранее:

- "Child Priv-Key 0" со стороны Боба соответствует: b.

- "Child Pub-Key 0" со стороны Алисы соответствует: A.

- "Payment Secret 0" соответствует: s.

- "Payment Pub-Key 0" соответствует: K0.

- "Payment Priv-Key 0" соответствует: k0.

Давайте подытожим шаги, которые мы только что рассмотрели вместе, чтобы получить платеж BIP47 и вычислить соответствующий приватный ключ:

- Боб выбирает первый производный дочерний приватный ключ из своего личного платежного кода.

- Он вычисляет секретную точку на эллиптической кривой, используя ECDH из первого производного дочернего публичного ключа из цепочки кодов Алисы.

- Используя эту секретную точку, он вычисляет общий секрет с помощью SHA256.

- Используя этот общий секрет, он вычисляет новую секретную точку на эллиптической кривой.

- Он добавляет эту новую секретную точку к своему личному публичному ключу.

- Он получает новый эфемерный публичный ключ, на который Алиса отправит свой первый платеж.

- Боб вычисляет приватный ключ, связанный с этим эфемерным публичным ключом, добавляя свой производный дочерний приватный ключ из своего платежного кода и общий секрет.

Поскольку Алиса не может получить "b", приватный ключ Боба, она не может определить k0, приватный ключ, связанный с приемным адресом Боба BIP47.

Схематически мы можем представить вычисление общего секрета "S" следующим образом:

![Вычисление общего секрета с ECDHE](assets/25.webp)

Как только общий секрет найден с помощью ECDH, Алиса и Боб вычисляют публичный ключ платежа BIP47 "K0", а Боб также вычисляет связанный с ним приватный ключ "k0".
![Производное получение адреса BIP47 из общего секрета](assets/26.webp)
### Возврат платежа по BIP47.

Поскольку Боб знает повторно используемый платежный код Алисы, у него уже есть вся необходимая информация, чтобы отправить ей возврат средств. Ему не нужно будет связываться с Алисой, чтобы запросить какую-либо информацию. Он просто уведомит ее с помощью уведомительной транзакции, особенно чтобы она могла восстановить свои адреса BIP47 с помощью своего сида, а затем он также может отправить ей до 2^32 платежей.
Таким образом, Боб может возместить Алисе так же, как она отправляла ему платежи. Роли меняются:

![Боб отправляет возврат Алисе с помощью BIP47](assets/27.webp)

Кредит: Повторно используемые платежные коды для иерархически детерминированных кошельков, Justus Ranvier. https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

Теперь вы знаете все тонкости этого великолепного решения, которое представляет собой BIP47.

## Производные использования PayNym.

Реализация этого BIP47 в кошельке Samourai привела к появлению PayNyms, идентификаторов, рассчитанных из платежных кодов пользователей. Сегодня их полезность выходит далеко за рамки использования BIP47.

Команда Samourai постепенно разрабатывает целую экосистему инструментов и сервисов на основе PayNym пользователя. Среди них, очевидно, все инструменты для расходов, которые позволяют оптимизировать конфиденциальность пользователя, добавляя энтропию в транзакцию и таким образом добавляя правдоподобное отрицание.

Совместное использование Soroban, зашифрованной сети связи на базе Tor, и PayNyms значительно оптимизировало пользовательский опыт при создании совместных транзакций, сохраняя при этом хороший уровень безопасности. Таким образом, легко выполнять транзакции Stowaway (PayJoin) и StonewallX2 без необходимости вручную выполнять многочисленные обмены неподписанными транзакциями, необходимыми для настройки такой совместной транзакции.

В отличие от использования BIP47, поскольку эти совместные транзакции не требуют уведомительной транзакции, достаточно связать PayNyms для использования этих инструментов. Нет необходимости их подключать.

Если вы хотите узнать больше о совместных транзакциях и, более широко, обо всех инструментах расходов кошелька Samourai, вы можете прочитать раздел "Инструменты расходов" в этой статье. Вы найдете техническое объяснение и подробное руководство по каждому инструменту.

Помимо этих совместных транзакций, недавно было замечено, что команда Samourai работает над протоколом аутентификации, связанным с PayNym: Auth47. Этот инструмент уже реализован и позволяет, например, аутентификацию с PayNym на веб-сайте, который принимает этот метод. В будущем, я думаю, что помимо этой возможности аутентификации в сети, Auth47 станет частью более крупного проекта вокруг экосистемы BIP47/PayNym/Samourai. Возможно, этот протокол будет использоваться для дальнейшей оптимизации пользовательского опыта кошелька Samourai, особенно при использовании инструментов расходов. Посмотрим...

## Мое личное мнение о BIP47.

Очевидно, основным недостатком BIP47 является уведомительная транзакция. Она заставляет пользователя тратить средства на ее майнинг, что может быть раздражающим для некоторых. Однако аргумент о "спаме" в блокчейне Bitcoin абсолютно неприемлем. Любой, кто платит сборы за свою транзакцию, должен иметь возможность записать ее в реестр, независимо от ее цели. Утверждать иначе - значит выступать за цензуру.

Возможно, в будущем будут найдены другие менее дорогие решения для передачи платежного кода отправителя получателю и для того, чтобы получатель мог безопасно его хранить. Но пока уведомительная транзакция остается решением с наименьшими компромиссами.
Этот недостаток остается незначительным, если учитывать все преимущества BIP47. Среди всех существующих предложений по решению проблемы повторного использования адресов оно представляется мне лучшим решением.
Как было объяснено ранее, большинство случаев повторного использования адресов происходит из-за бирж. BIP47 является единственным разумным решением, которое действительно решает эту проблему у самого истока. Любое предложение, направленное на сокращение числа повторных использований адресов, должно сосредоточиться на этом аспекте и адаптировать решение к основному источнику проблемы.

С точки зрения удобства использования, несмотря на то что внутреннее устройство довольно сложное, процедура оплаты BIP47 проста и понятна. Таким образом, повторно используемые платежные коды могут быть легко приняты даже начинающими пользователями.

С точки зрения конфиденциальности, BIP47 представляет большой интерес. Как я объяснил в разделе о транзакции уведомления, платежный код не раскрывает никакой информации о производных эфемерных адресах. Таким образом, он прерывает поток информации между биткойн-транзакцией и идентификатором получателя, в отличие от традиционного использования адреса получения.

И прежде всего, реализация PayNym для BIP47 работает! Она доступна в кошельке Samourai Wallet с 2016 года и в Sparrow Wallet с начала этого года. Это не научный проект, а решение, которое было протестировано вчера и полностью функционально сегодня.

Надеюсь, в будущем эти повторно используемые платежные коды будут приняты участниками экосистемы, реализованы в программном обеспечении кошельков и использованы биткойнерами.

Любое действительно положительное решение для конфиденциальности пользователей должно обсуждаться, продвигаться и защищаться, чтобы Биткойн не стал игровой площадкой CA и инструментом слежения правительств.
Он подумал о том, как его везде преследовали и оскорбляли, а теперь все говорили, что он самый красивый из всех этих прекрасных птиц! И даже бузина наклонила свои ветви к нему, а солнце распространило такой теплый и благосклонный свет! Тогда его перья раздулись, его стройная шея выпрямилась, и он воскликнул всем сердцем: "Как я мог мечтать о таком счастье, когда был просто некрасивым маленьким утенком."

## Для дальнейшего изучения:

- Понимание и использование CoinJoin в Биткойне.

- Понимание путей производных ключей биткойн-кошелька.

- Установка и использование вашего Bitcoin-узла RoninDojo.

### Внешние ресурсы и благодарности:

Благодарю LaurentMT и Théo Pantamis за множество концепций, которые они мне объяснили и которые я использовал в этой статье. Надеюсь, я смог точно их передать.

Благодарю Fanis Michalakis за корректуру этого текста и его экспертные советы.

- https://bitcoiner.guide/paynym/
- https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki
- https://fr.wikipedia.org/wiki/%C3%89change_de_cl%C3%A9s_Diffie-Hellman
- https://fr.wikipedia.org/wiki/%C3%89change_de_cl%C3%A9s_Diffie-Hellman_bas%C3%A9_sur_les_courbes_elliptiques
- https://security.stackexchange.com/questions/46802/what-is-the-difference-between-dhe-and-ecdh#:~:text=The%20difference%20between%20DHE%20and%20ECDH%20in%20two%20bullet%20points,a%20type%20of%20algebraic%20curve).
- https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art060
- https://ee.stanford.edu/~hellman/publications/24.pdf
- https://www.researchgate.net/publication/317339928_A_study_on_diffie-hellman_key_exchange_protocols